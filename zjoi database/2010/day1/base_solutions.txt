ZJOI2010 base Solution

[analysis]

n表示村庄数量，m表示基站数量。
设f[i,j]表示在第i个村庄建第j个基站。
d[i]表示第i个村庄的位置，c[i]表示在第i个村庄建立基站的费用，w[i]表示第i村庄未被覆盖的费用，s[i]表示第i村庄的覆盖距离。
b[i]=d[i]-s[i]表示可以覆盖第i个村庄的最小位置，e[i]=d[i]+s[i]表示可以覆盖第i个村庄的最大位置。

1.before的计算：
若d[j]小于b[i]那么j一定不能覆盖i。又因为d满足单调性，所以可以二分查找。

2.状态转移方程：
f[i,j]=min{f[k,j-1]+cost(k,i)}+c[i],1<=j<=m,j<=i<=n+1,j-1<=k<=i-1
我们在最后添加第n+1个村庄，d[n+1]=oo，我们设在这个村庄建基站，那么ans=min{f[n,i]},1<=i<=m+1。
其中cost(k,i)=sigma{w[x]},x表示村庄k和i之间的没有覆盖的村庄。不能覆盖的判断条件是(b[x]>d[k] & e[x]<d[i])
时间复杂度：O(n^3*m)。
显然无法承受。

3.优化：
对于同一个i,j（下面的讨论都是在i,j一定的前提下进行的，故下标中不出现j,weight中不出现i），我们设weight[k]=f[k,j-1]+cost(k,i)，则方程变成下面的形式：
f[i]=min{weight[k]}+c[i],这里出现了区间最小值的形式，也就是要取[j-1,i-1]中的最小的weight[k]，我们考虑用线段树维护weight[k]。
我们假设村庄x不被覆盖，那么有：b[x]>d[k] & e[x]<d[i]
因为i是确定的，所以我们只需要知道k的范围使得b[x]>d[k]。
设before[i]表示在第i个村庄之前不可以覆盖第i个村庄的最大位置。那么显然的k的范围就是[j-1,before[x]]，所以这个范围内我们都要加上w[x]。然后我们再取[j-1,i-1]中的最小值进行决策。
显然如果对于i，x在决策区间[j-1,before[x]]不能被覆盖，那么随着i的推移，x在决策区间[j-1,before[x]]仍然不能被覆盖。而且可能会有加入一些新的会出现不能被覆盖的村庄。于是，我们把e按照递增顺序排序，这样每个x只会被算一次，均摊复杂度是O(1)。
这样优化后，时间复杂度为O(nmlogn)。